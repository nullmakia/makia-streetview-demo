<!doctype html>
<html lang="ja">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Street View × GPS × キャラ反応</title>

<style>
  html, body, #pano { height: 100%; margin: 0; background: #000; }
  #pano {
    position: fixed;
    inset: 0;
    z-index: 0;            /* 背景として最背面に固定 */
  }
  /* —— キャラ（前景） —— */
  .sprite {
    position: fixed;
    z-index: 2000;         /* パノラマより十分手前に */
    pointer-events: auto;
    touch-action: manipulation;
    image-rendering: auto;
    filter: drop-shadow(0 8px 14px rgba(0,0,0,.35));
    will-change: transform;
    user-select: none;
  }
  /* 少年（左寄り・下） */
  .boy {
    left: 12vw; bottom: 10vh;
    width: min(40vw, 320px);
    aspect-ratio: 5/6;
    background: url('fool1.png') center / contain no-repeat;
  }
  /* ↓ 少年の右横に寄せる：少年の左位置 + 少年の幅 + 隙間(6vw) */
  .dog {
    /* 少年 left(12vw) + 少年幅 + 隙間(3vw) → さらに左寄せ */
    left: calc(6vw + min(20vw, 100px) + 15vw);
    bottom: 11vh;
    width: min(15vw, 200px);
    aspect-ratio: 5/6;
    background: url('fool2.png') center / contain no-repeat;
  }

  /* 影（簡易） */
  .shadow { z-index: 1500; } /* 影はキャラより背面だがパノラマより前 */

  /* 反応アニメ（少年：ぴょん＋手を振る風の揺れ） */
  @keyframes boyJump {
    0%   { transform: translateY(0) rotate(0deg) }
    20%  { transform: translateY(-14px) rotate(-2deg) }
    40%  { transform: translateY(-22px) rotate(2deg) }
    60%  { transform: translateY(-10px) rotate(-1deg) }
    100% { transform: translateY(0) rotate(0deg) }
  }
  .boy.react { animation: boyJump .7s ease-out; }

  /* 反応アニメ（犬：首ぶんぶん＋小ジャンプ） */
  @keyframes dogShake {
    0% { transform: translateY(0) rotate(0deg) }
    15% { transform: translateY(-6px) rotate(-6deg) }
    30% { transform: translateY(-6px) rotate(6deg) }
    45% { transform: translateY(-6px) rotate(-6deg) }
    60% { transform: translateY(-2px) rotate(4deg) }
    100%{ transform: translateY(0) rotate(0deg) }
  }
  .dog.react { animation: dogShake .6s ease-out; }

  /* セリフふきだし */
  .bubble {
    position: absolute; left: 50%; bottom: 100%;
    transform: translateX(-50%);
    white-space: nowrap;
    background: rgba(255,255,255,.95);
    color: #222; font: 600 14px/1.2 system-ui, -apple-system, "Segoe UI", sans-serif;
    padding: 8px 10px; border-radius: 14px;
    border: 1px solid rgba(0,0,0,.15);
    box-shadow: 0 6px 12px rgba(0,0,0,.18);
    opacity: 0; animation: pop .75s ease forwards;
    z-index: 20;
  }
  @keyframes pop {
    0% { transform: translate(-50%, 6px) scale(.9); opacity: 0; }
    40%{ transform: translate(-50%, 0)   scale(1);   opacity: 1; }
    90%{ opacity: 1; }
    100%{ opacity: 0; }
  }

  /* 既存の .hud に position を付けて最前面に固定 */
  .hud {
    position: fixed;
    top: 12px;
    left: 12px;
    z-index: 3000;
  }
  .hud button { padding: 6px 8px; border: 0; border-radius: 8px; }
  /* === テロップとマイク開始ボタン === */
  #aiTelopBox{
    position:fixed; left:12px; right:12px; bottom:12px;
    padding:10px 12px; background:rgba(255,255,255,.92);
    border:1px solid #e5e5e5; border-radius:12px; backdrop-filter:blur(4px);
    box-shadow:0 4px 18px rgba(0,0,0,.12); z-index:4000; font-size:14px;
  }
  #aiTelopBox .label{ font-weight:700; margin-right:6px; }
  #micStart{
    position:fixed; right:12px; bottom:80px; z-index:4001;
    padding:10px 12px; border:1px solid #111; background:#111; color:#fff; border-radius:10px;
  }
  /* === 吹き出し（Fool の返答）=== */
  #foolBalloon {
    position: fixed;
    left: 12px;
    right: 12px;
    bottom: 12px;
    max-width: 92vw;
    background: #fff;
    border: 1px solid #e5e7eb;
    border-radius: 14px;
    padding: 10px 12px;
    box-shadow: 0 6px 20px rgba(0,0,0,.14);
    font-size: 14px;
    line-height: 1.5;
    z-index: 4000;
  }
  #foolBalloon .name {
    display: inline-block; font-weight: 700; margin-right: 6px;
    background: #111; color: #fff; padding: 2px 8px; border-radius: 999px; font-size: 12px;
  }
  #foolBalloon:after {
    content: ""; position: absolute; left: 20px; bottom: -8px;
    border-width: 8px 8px 0 8px; border-style: solid;
    border-color: #fff transparent transparent transparent;
    filter: drop-shadow(0 -1px 0 rgba(0,0,0,.08));
  }
  /* マイク許可のオーバーレイ（必要時のみ表示） */
  #micPerm {
    position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
    background: rgba(0,0,0,.35); z-index: 5000;
  }
  #micPerm .box {
    background:#fff; padding:16px 18px; border-radius:12px; max-width: 90vw; text-align:center;
    box-shadow:0 8px 28px rgba(0,0,0,.2); font-size:14px;
  }
  #micPerm button {
    margin-top:10px; padding:10px 12px; border-radius:10px; border:1px solid #111; background:#111; color:#fff;
  }

</style>

<body>
  <div id="pano" aria-label="Street View 背景"></div>

  <!-- 前景キャラ -->
  <div class="sprite boy" id="boy"></div>
  <div class="sprite dog" id="dog"></div>
  <div class="shadow" aria-hidden="true"></div>

  <!-- 状態表示 / iOSモーション許可 -->
  <div class="hud">
    <div>状態: <span id="st">初期化中…</span></div>
    <div>速度: <span id="spd">0.0</span> m/s　方位: <span id="hdg">—</span>°</div>
  </div>
  <!-- 画面にトグルとキャリブレーションを追加 -->
  <button id="btnGyro" style="position:fixed;right:8px;bottom:64px;z-index:1000;">🎯 ジャイロOFF</button>
  <button id="btnCal"  style="position:fixed;right:8px;bottom:28px;z-index:1000;">↻ 方向校正</button>
  <div id="foolBalloon"><span class="name">Fool</span><span id="aiTelop">準備中…</span></div>

  <!-- 自動開始がブロックされた場合だけ出す（iOS Safari想定） -->
  <div id="micPerm" aria-hidden="true">
    <div class="box">
      🎤 マイクを有効化してください（1回だけタップ）<br>
      <button id="enableMic">マイクを許可して開始</button>
    </div>
  </div>
<script>
// 既存の変数に追加
let gyroMode = false;           // ジャイロで視線を制御するか
let headingOffset = 0;          // 校正用オフセット（度）
let smoothedHeading = null;     // 既存の平滑化済みヘディングを再利用
let lastDeviceHeading = null;   // 端末からの最新ヘディング

const toRad = d => d * Math.PI / 180;
const toDeg = r => r * 180 / Math.PI;
const norm360 = a => (a % 360 + 360) % 360;
const shortestDeltaDeg = (a,b) => {
  let d = norm360(b) - norm360(a);
  if (d > 180) d -= 360;
  if (d < -180) d += 360;
  return d;
};
function smoothAngle(prev, next, alpha = 0.25) {
  if (prev == null) return next;
  const delta = shortestDeltaDeg(prev, next);
  return norm360(prev + alpha * delta);
}

// 端末向き → 方位に変換（iOS/Android両対応）
function extractCompassHeadingFromEvent(e) {
  // iOS Safari: webkitCompassHeading が「真北から時計回り（度）」
  if (typeof e.webkitCompassHeading === 'number' && !isNaN(e.webkitCompassHeading)) {
    return norm360(e.webkitCompassHeading + headingOffset);
  }
  // それ以外: alpha はデバイス座標(Z軸)の回転。画面の回転を補正する
  if (typeof e.alpha === 'number') {
    const so = screen.orientation?.angle || window.orientation || 0; // 0,90,180,270
    // 端末を縦持ち前提の簡易補正（必要なら微調整可）
    // コンパス的な北基準に合わせるため 360 - alpha
    let heading = 360 - e.alpha;
    // 画面回転を足す
    heading = heading + so;
    return norm360(heading + headingOffset);
  }
  return null;
}

// StreetViewの視線を更新
function setPovHeadingPitch(headingDeg, pitchDeg = null) {
  if (!pano) return;
  const pov = pano.getPov();
  const target = {
    heading: headingDeg != null ? headingDeg : (pov.heading ?? 0),
    pitch:   pitchDeg   != null ? pitchDeg   : (pov.pitch ?? 0),
    zoom:    pov.zoom ?? 1
  };
  // 小さな揺れは無視
  const delta = Math.abs(shortestDeltaDeg(pov.heading ?? 0, target.heading));
  if (delta < 5 && (pitchDeg == null || Math.abs((pov.pitch??0)-target.pitch) < 2)) return;
  pano.setPov(target);
}

// DeviceOrientation ハンドラ
function onDeviceOrientation(e) {
  const h = extractCompassHeadingFromEvent(e);
  if (h == null) return;
  lastDeviceHeading = h;

  // 低速/停止時だけジャイロで視線を制御（速度は既存UI/変数から取得）
  const spdEl = document.getElementById('spd');
  const speed = spdEl ? parseFloat(spdEl.textContent) : 0;

  if (gyroMode && (isNaN(speed) || speed < 2.0)) {
    smoothedHeading = smoothAngle(smoothedHeading, h, 0.25);
    setPovHeadingPitch(smoothedHeading);
    const hdgEl = document.getElementById('hdg');
    if (hdgEl) hdgEl.textContent = smoothedHeading.toFixed(0);
  }
}

// iOS の許可要求 + 監視開始
async function enableDeviceOrientation() {
  const C = window.DeviceOrientationEvent;
  if (!C) return { ok:false, reason:'DeviceOrientation未対応' };

  try {
    if (typeof C.requestPermission === 'function') {
      const state = await C.requestPermission();
      if (state !== 'granted') return { ok:false, reason:'許可されませんでした' };
    }
    window.addEventListener('deviceorientation', onDeviceOrientation, true);
    return { ok:true };
  } catch (e) {
    return { ok:false, reason: e?.message || '不明なエラー' };
  }
}

// ジャイロON/OFFトグル
document.getElementById('btnGyro').addEventListener('click', async () => {
  if (!gyroMode) {
    const { ok, reason } = await enableDeviceOrientation();
    if (!ok) { alert('ジャイロを使えません: ' + reason); return; }
    gyroMode = true;
    document.getElementById('btnGyro').textContent = '🎯 ジャイロON';
  } else {
    gyroMode = false;
    document.getElementById('btnGyro').textContent = '🎯 ジャイロOFF';
  }
});

// 現在の向きを「正面」に校正（端末を向けた方向を0°とみなす）
document.getElementById('btnCal').addEventListener('click', () => {
  if (lastDeviceHeading == null) return;
  // 直近のヘディングを正面にするためのオフセットを再計算
  headingOffset = norm360((smoothedHeading ?? lastDeviceHeading) - lastDeviceHeading);
});
</script>

<script type="module">
  // ===== Street View 起動（importLibrary 方式） =====
  const FALLBACK = { lat: 35.6595, lng: 139.7005 }; // 渋谷駅周辺を保険として
  let lastPanoId = null;

  // 既存のジャイロコードが参照できるように window 経由で公開
  window.pano = null;
  window.sv   = null;

  // 近傍パノラマへ移動する共通関数
  function showNearestPanorama(location, radius = 150, tag = '') {
    window.sv.getPanorama({ location, radius }, (data, status) => {
      if (status === 'OK' && data?.location) {
        const panoId = data.location.pano;
        if (panoId !== lastPanoId) {
          window.pano.setPano(panoId);
          lastPanoId = panoId;
          // 視線は進行方向ロジックやジャイロで後から上書きされる想定
        }
      } else {
        // 見つからなければ少し半径を広げて再試行（最大400m）
        if (radius < 400) showNearestPanorama(location, Math.min(400, radius + 100), tag);
      }
    });
  }

  async function boot() {
    // Google Maps ライブラリの動的読み込み
    await google.maps.importLibrary("maps");
    await google.maps.importLibrary("streetView");

    // Street View 準備
    window.sv = new google.maps.StreetViewService();
    window.pano = new google.maps.StreetViewPanorama(
      document.getElementById('pano'),
      {
        addressControl: false,
        fullscreenControl: false,
        motionTracking: false,
        disableDefaultUI: true,
        visible: true
      }
    );

    // 1) まず必ずフォールバックを表示（黒画面防止）
    showNearestPanorama(FALLBACK, 200, 'init');

    // 2) 位置情報が取れたらそちらへ切替
    const st  = document.getElementById('st');
    if ('geolocation' in navigator) {
      navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude, accuracy, speed } = pos.coords;
        const spd = document.getElementById('spd');
        if (spd) spd.textContent = (speed || 0).toFixed(1);
        if (st) st.textContent = `測位OK（±${Math.round(accuracy||0)}m）`;
        showNearestPanorama({ lat: latitude, lng: longitude }, 150, 'gps');
      }, err => {
        if (st) st.textContent = `測位エラー: ${err.message}（fallback表示を継続）`;
      }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 15000 });
    } else {
      if (st) st.textContent = 'Geolocation未対応（fallback表示）';
    }
  }

  // google.maps が来たら起動
  const ready = () => (window.google?.maps?.importLibrary) ? boot() : setTimeout(ready, 30);
  ready();
</script>

<script>
// 反応アニメ & ふきだし
function bounce(el, cls) {
  el.classList.remove(cls); void el.offsetWidth; el.classList.add(cls);
  el.addEventListener('animationend', () => el.classList.remove(cls), { once:true });
}
function bubble(el, text) {
  const b = document.createElement('div');
  b.className = 'bubble'; b.textContent = text; el.appendChild(b);
  setTimeout(() => b.remove(), 800);
}

// キャラにイベント付与（クリック & タッチ）
const boy = document.getElementById('boy');
const dog = document.getElementById('dog');

['click','touchend'].forEach(type => {
  boy.addEventListener(type, (e) => {
    if (type === 'touchend') e.preventDefault();
    bounce(boy, 'react'); bubble(boy, 'いこう！');
  }, { passive:false });

  dog.addEventListener(type, (e) => {
    if (type === 'touchend') e.preventDefault();
    bounce(dog, 'react'); bubble(dog, 'ワン！');
  }, { passive:false });
});
</script>
<script>
/** GitHub Pages から Cloudflare Worker を叩いて結果を表示する自動テスト */
(async () => {
  // ← 実URLに置換してください（/chat を忘れずに）
  const WORKER_ENDPOINT = "https://makia-animator.animator.workers.dev/chat";

  const out = document.getElementById("aiResult");
  try {
    const res = await fetch(WORKER_ENDPOINT, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        stream: false, // まずはJSONで確認。SSEは慣れてから
        messages: [{ role: "user", content: "疎通テスト：1行で返答して" }]
      }),
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();
    const text = data?.choices?.[0]?.message?.content ?? JSON.stringify(data);
    out.textContent = text;
  } catch (e) {
    console.error("Worker fetch error", e);
    out.textContent = "APIエラー: " + (e?.message || e);
  }
})();
</script>
<script>
(() => {
  // ← 必ずあなたの実URLに（末尾 /chat と /stt）
  const WORKER_BASE = "https://makia-animator.animator.workers.dev";
  const CHAT_URL = WORKER_BASE + "/chat";
  const STT_URL  = WORKER_BASE + "/stt";

  const telop = document.getElementById("aiTelop");
  const perm  = document.getElementById("micPerm");
  const btn   = document.getElementById("enableMic");

  const setTelop = (t) => { telop.textContent = t };

  // 準備中を最低この時間は表示（必要に応じて調整）
  const MIN_PREP_MS = 1500; // ← 1.5秒。もっと長くしたければ 2000~2500 などに
  let prepStartedAt = 0;

  const setPreparing = (why = "") => {
    prepStartedAt = performance.now();
    setTelop("準備中…" + (why ? `（${why}）` : ""));
  };

  const setReady = () => {
    const elapsed = performance.now() - prepStartedAt;
    const rest = MIN_PREP_MS - elapsed;
    if (rest > 0) {
      setTimeout(() => setTelop("話しかけてね！"), rest);
    } else {
      setTelop("話しかけてね！");
    }
  };

  // ==== 返答をSSEで逐次テロップ ====
  async function askChat(userText) {
    try {
      const res = await fetch(CHAT_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          stream: true,
          messages: [
            { role: "system", content: "あなたは元気な少年キャラ『Fool』です。短い日本語セリフで返答。敬称は不要。絵文字は控えめ。" },
            { role: "user", content: userText }
          ]
        })
      });
      if (!res.ok || !res.body) { telop.textContent = "接続エラー(" + res.status + ")"; return; }

      telop.textContent = ""; // 返答開始で消す
      const reader = res.body.getReader();
      const dec = new TextDecoder();
      let buf = "";
      for (;;) {
        const { value, done } = await reader.read();
        if (done) break;
        buf += dec.decode(value, { stream:true });
        let nl;
        while ((nl = buf.indexOf("\n")) >= 0) {
          const line = buf.slice(0, nl).trim(); buf = buf.slice(nl + 1);
          if (!line.startsWith("data:")) continue;
          const payload = line.slice(5).trim();
          if (payload === "[DONE]") { buf = ""; break; }
          try {
            const j = JSON.parse(payload);
            const delta = j?.choices?.[0]?.delta?.content || "";
            if (delta) telop.textContent += delta;
          } catch {}
        }
      }
    } catch (e) {
      telop.textContent = "通信エラー: " + (e?.message || e);
    }
  }

  // ==== 音声→文字（優先：Web Speech / 代替：MediaRecorder + /stt） ====
  let rec = null, stream = null, chunks = [], usingSpeechAPI = false, running = false, lastText = "";

  function setupSpeechAPI() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) return null;
    const r = new SR();
    r.lang = "ja-JP";
    r.interimResults = false;
    r.continuous = true;
    r.maxAlternatives = 1;

    // ★ ここは“準備中のまま”にする
    r.onstart = () => { running = true; setPreparing("待機中"); };

    // ★ 実際に音声取り込みが開始したら Ready にする
    r.onaudiostart  = () => setReady();
    r.onsoundstart  = () => setReady(); // 端末によってはこっちが先に来る

    r.onend   = () => {
      running = false;
      setPreparing("待機中");
      setTimeout(()=>{ try { r.start(); } catch {} }, 200);
    };
    r.onerror = (e) => {
      if (e.error === "not-allowed" || e.error === "service-not-allowed") {
        showPerm();
        setPreparing("マイク許可が必要");
      }
    };
    r.onresult = (ev) => {
      let t = "";
      for (let i = ev.resultIndex; i < ev.results.length; i++) {
        if (ev.results[i].isFinal) t += ev.results[i][0].transcript;
      }
      t = (t || "").trim();
      if (t && t !== lastText) { lastText = t; askChat(t); }
    };
    usingSpeechAPI = true;
    return r;
  }


  async function startMediaRecorder() {
    try {
      setPreparing("マイク初期化中");
      stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true } });
    } catch (e) {
      showPerm(); setPreparing("マイク許可が必要"); return;
    }
    const m = new MediaRecorder(stream, { mimeType: "audio/webm" });
    chunks = [];

    // ★ 録音が“本当に開始”した瞬間に Ready
    m.onstart = () => setReady();

    m.ondataavailable = e => { if (e.data.size) chunks.push(e.data); };
    m.onstop = async () => {
      if (!chunks.length) return;
      const blob = new Blob(chunks, { type: "audio/webm" });
      chunks = [];
      try {
        const res = await fetch(STT_URL, {
          method: "POST",
          headers: { "Content-Type": "audio/webm" },
          body: await blob.arrayBuffer()
        });
        const { text = "" } = await res.json();
        const t = (text || "").trim();
        if (t && t !== lastText) {
          lastText = t;
          askChat(t);
        }
      } catch (e) { /* 無視（次サイクルへ） */ }
      // 連続収音
      if (running) { try { m.start(2000); } catch {} }
    };
    rec = m; running = true;
    try { m.start(2000); } catch {}
  }

  function showPerm() { perm.style.display = "flex"; }
  function hidePerm() { perm.style.display = "none"; }

  async function startListening() {
    if (running) return;
    // 1) Web Speech API が使えれば優先（超低レイテンシ）
    rec = setupSpeechAPI();
    if (rec) { try { rec.start(); } catch { showPerm(); } return; }
    // 2) 使えなければ MediaRecorder + /stt（広い互換性）
    await startMediaRecorder();
  }

  function stopListening() {
    running = false;
    if (usingSpeechAPI && rec) try { rec.stop(); } catch {}
    if (!usingSpeechAPI && rec) try { rec.stop(); } catch {}
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
  }

  // 自動開始をまず試みる（許可済みブラウザではボタン不要で走る）
  setPreparing("マイク初期化中");   
  startListening();

  // 自動開始がブロックされた場合のみ、ワンタップで開始
  btn?.addEventListener("click", async () => { hidePerm(); setPreparing("マイク初期化中"); await startListening(); }); // ← 変更

  // ページ離脱で停止
  window.addEventListener("pagehide", stopListening);
})();
</script>

<!-- ★YOUR_API_KEY をあなたのキーに置き換え -->
<script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAQQHZONAJ27HZwG20IJbRYZXZ6ADxbtP0&v=weekly"></script>
</body>
</html>
