<!doctype html>
<html lang="ja">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Street View × キャラ × 音声会話（Step3統合）</title>

<style>
  html, body, #pano { height: 100%; margin: 0; background: #000; }
  #pano { position: fixed; inset: 0; z-index: 0; }

  /* —— キャラ（前景） —— */
  .sprite { position: fixed; z-index: 2000; pointer-events: auto; touch-action: manipulation;
    filter: drop-shadow(0 8px 14px rgba(0,0,0,.35)); user-select: none; }
  .boy { left: 12vw; bottom: 10vh; width: min(40vw, 320px); aspect-ratio: 5/6;
    background: url('fool1.png') center / contain no-repeat; }
  .dog { left: calc(6vw + min(20vw, 100px) + 15vw); bottom: 11vh; width: min(15vw, 200px); aspect-ratio: 5/6;
    background: url('fool2.png') center / contain no-repeat; }

  @keyframes boyJump { 0%{transform:translateY(0) rotate(0)}20%{transform:translateY(-14px) rotate(-2deg)}40%{transform:translateY(-22px) rotate(2deg)}60%{transform:translateY(-10px) rotate(-1deg)}100%{transform:translateY(0) rotate(0)} }
  .boy.react { animation: boyJump .7s ease-out; }
  @keyframes dogShake { 0%{transform:translateY(0) rotate(0)}15%{transform:translateY(-6px) rotate(-6deg)}30%{transform:translateY(-6px) rotate(6deg)}45%{transform:translateY(-6px) rotate(-6deg)}60%{transform:translateY(-2px) rotate(4deg)}100%{transform:translateY(0) rotate(0)} }
  .dog.react { animation: dogShake .6s ease-out; }

  .bubble{ position:absolute; left:50%; bottom:100%; transform:translateX(-50%); white-space:nowrap;
    background:rgba(255,255,255,.95); color:#222; font:600 14px/1.2 system-ui,-apple-system,"Segoe UI",sans-serif;
    padding:8px 10px; border-radius:14px; border:1px solid rgba(0,0,0,.15); box-shadow:0 6px 12px rgba(0,0,0,.18);
    opacity:0; animation:pop .75s ease forwards; z-index: 20; }
  @keyframes pop { 0%{transform:translate(-50%,6px) scale(.9); opacity:0}40%{transform:translate(-50%,0) scale(1); opacity:1}90%{opacity:1}100%{opacity:0} }

  /* HUD / テロップ / マイクボタン */
  .hud { position: fixed; top: 12px; left: 12px; z-index: 3000; color: #fff; text-shadow:0 1px 3px rgba(0,0,0,.6) }
  #aiTelopBox{ position:fixed; left:12px; right:12px; bottom:12px; padding:10px 12px; background:rgba(255,255,255,.92);
    border:1px solid #e5e5e5; border-radius:12px; backdrop-filter:blur(4px); box-shadow:0 4px 18px rgba(0,0,0,.12);
    z-index:4000; font-size:14px; }
  #stopBtn{ position:fixed; right:12px; bottom:80px; z-index:4001; padding:10px 12px; border:1px solid #111;
    background:#444; color:#fff; border-radius:10px; }

  .meter{ display: none; }
  .bar{ height:100%; width:0% }
  .hidden { display: none !important; }
</style>

<body>
  <div id="pano" aria-label="Street View 背景"></div>

  <!-- 前景キャラ -->
  <div class="sprite boy" id="boy"></div>
  <div class="sprite dog" id="dog"></div>

  <!-- HUD -->
  <div class="hud">
    <div>状態: <span id="st">初期化中…</span></div>
    <div>速度: <span id="spd">0.0</span> m/s　方位: <span id="hdg">—</span>°</div>
  </div>

  <video id="cam" autoplay playsinline muted
    style="position:fixed; inset:0; width:100%; height:100%; object-fit:cover; z-index:0; display:none; pointer-events:none;">
  </video>

  <!-- テロップ / マイク -->
  <div id="aiTelopBox"><span id="aiTelop">タップで開始</span></div>
  <button id="camBtn" style="position:fixed; right:12px; bottom:180px; z-index:4001; padding:10px 12px; border:1px solid #111; background:#07a; color:#fff; border-radius:10px;">
    📷 カメラON
  </button>
  <button id="gyroBtn" style="position:fixed; right:12px; bottom:142px; z-index:4001; padding:10px 12px; border:1px solid #111; background:#0a7; color:#fff; border-radius:10px;">
    🧭 方角追従ON
  </button>
  <button id="stopBtn" disabled>■ 停止</button>
  <div class="meter"><div id="levelBar" class="bar"></div></div>

<script>
/***** 設定（あなたのWorkerのエンドポイントに差し替え） *****/
const WORKER_BASE = "https://makia-animator.animator.workers.dev"; // 例
const STT_URL = WORKER_BASE + "/stt";        // 音声→テキスト（Step3のバッチ）
const CHAT_URL = WORKER_BASE + "/chat";       // テキスト→会話応答（ストリーミング可）

/***** テロップ *****/
const telop = document.getElementById("aiTelop");
const stHud = document.getElementById("st");
function setStatus(t){ stHud.textContent = t; }          // ← 状態はHUDだけ
function clearReply(){ telop.textContent = ''; }         // ← 会話表示を消す
function showReplyThinking(){ telop.textContent = '…考え中'; } // ← 会話前の一瞬だけ使う
function appendReplyChunk(s){ telop.textContent += s; }  // ← ストリーミング追加

const boy = document.getElementById('boy');
const dog = document.getElementById('dog');

/***** キャラの反応 *****/
function bounce(el, cls){ el.classList.remove(cls); void el.offsetWidth; el.classList.add(cls);
  el.addEventListener('animationend', ()=> el.classList.remove(cls), { once:true }); }
function bubble(el, text){ const b=document.createElement('div'); b.className='bubble'; b.textContent=text; el.appendChild(b); setTimeout(()=> b.remove(), 800); }
  ['click','touchend'].forEach(type => {
    boy.addEventListener(type, async e=>{
      if(type==='touchend') e.preventDefault();
      bounce(boy,'react');
      bubble(boy,'いこう！');
      if (window.rec?.state === 'recording') return;
  
      forceStopVisible = true;
      stopBtn.classList.remove('hidden');
      stopBtn.style.display = 'block';
  
      startRecording();
      setUIHidden(uiHidden);
    }, {passive:false});
  
    // ★ 犬タップでUIの表示/非表示を切り替え
    dog.addEventListener(type, e=>{
      if(type==='touchend') e.preventDefault();
      bounce(dog,'react');
      bubble(dog,'ワン！');
      setUIHidden(!uiHidden);   // ← これでトグル
    }, {passive:false});
  });


/***** Street View（最小起動） *****/
window.pano = null; window.sv = null;
const FALLBACK = { lat: 35.6595, lng: 139.7005 };
function showNearestPanorama(location, radius=150){
  window.sv.getPanorama({ location, radius }, (data, status) => {
    if (status === 'OK' && data?.location) {
      window.pano.setPano(data.location.pano);
     const el = document.getElementById('pano');
     if (el && el.style.display !== 'none') reflowStreetView();    }
  });
}
async function bootMaps(){
  await google.maps.importLibrary("maps");
  await google.maps.importLibrary("streetView");
  window.sv = new google.maps.StreetViewService();
  window.pano = new google.maps.StreetViewPanorama(document.getElementById('pano'),{
    addressControl:false,
    fullscreenControl:false,
    disableDefaultUI:true,
    visible:true,
    // iOS/Android の「端末の向きで回す」をMaps側に任せる（任せたくないなら true→false のままでもOK）
    motionTracking:true,
    motionTrackingControl:false
  });

  showNearestPanorama(FALLBACK, 200);
  if ('geolocation' in navigator) {
    navigator.geolocation.watchPosition(pos=>{
      const { latitude, longitude, accuracy, speed } = pos.coords;
      const spdEl = document.getElementById('spd'); if (spdEl) spdEl.textContent = (speed||0).toFixed(1);
      showNearestPanorama({lat:latitude,lng:longitude}, 150);
    });
  }
}
(function ready(){ if (window.google?.maps?.importLibrary) bootMaps(); else setTimeout(ready, 30); })();

/***** カメラ3状態トグル（off / back / front） *****/
const camBtn = document.getElementById("camBtn");
const camEl  = document.getElementById("cam");
const panoEl = document.getElementById("pano");

let camStream = null;
/** 'off' | 'back' | 'front' */
let camMode = 'off';

function stopCamStream(){
  try { camStream && camStream.getTracks().forEach(t=>t.stop()); } catch {}
  camStream = null;
}

function updateCamUI(){
  if (camMode === 'off') {
    camEl.style.display = "none";
    panoEl.style.display = "block";
    camBtn.textContent = "📷 外カメラ";
    setStatus("Street View");    // ← ここ
  } else if (camMode === 'back') {
    camEl.style.display = "block";
    panoEl.style.display = "none";
    camBtn.textContent = "🤳 内カメラ";
    setStatus("カメラ（外）");
  } else {
    camEl.style.display = "block";
    panoEl.style.display = "none";
    camBtn.textContent = "🗺️ OFF（SV）";
    setStatus("カメラ（内）");
  }
}

async function switchTo(nextMode){
  // 既存ストリーム停止
  stopCamStream();

  if (nextMode === 'off') {
    camMode = 'off';
    camEl.style.display = "none";
    panoEl.style.display = "block";
    updateCamUI();
    // ★ 追加：SVを確実に再描画（ハードモードで）
    reflowStreetView(true);
    return;
  }

  const want = nextMode === 'back' ? "environment" : "user";
  const exact = { exact: want };
  const getWith = (fm) => navigator.mediaDevices.getUserMedia({
    video: { facingMode: fm, width:{ideal:1280}, height:{ideal:720} },
    audio: false
  });

  try {
    try { camStream = await getWith(exact); }
    catch { camStream = await getWith(want); }

    const vtrack = camStream.getVideoTracks()[0];
    if (!vtrack) throw new Error("no video track");

    camMode = nextMode;

    // ★ 先に表示を切り替え → srcObject → play() の順（黒対策）
    panoEl.style.display = "none";
    camEl.style.display  = "block";
    camEl.muted = true;
    camEl.setAttribute('playsinline','true');
    camEl.setAttribute('webkit-playsinline','true');

    camEl.srcObject = camStream;

    try {
      await camEl.play();
    } catch {
      await new Promise(r => camEl.addEventListener('loadedmetadata', r, {once:true}));
      try { await camEl.play(); } catch {}
    }

    updateCamUI();

    // 保険：500ms後にまだ真っ黒ならもう一度 play
    setTimeout(()=>{
      if (camMode!=='off' && camEl.videoWidth === 0) {
        camEl.play().catch(()=>{});
      }
    }, 500);

  } catch (e) {
    setStatus("カメラ開始できません: " + (e?.name || "") + " " + (e?.message || e));
    camMode = 'off';
    camEl.style.display = "none";
    panoEl.style.display = "block";
    updateCamUI();
  }
}

function reflowStreetView(hard = false) {
  if (!window.pano) return;
  // 表示状態を保証
  panoEl.style.display = 'block';
  try {
    // 可視化+リサイズ通知で再描画を促す
    window.pano.setVisible(true);
    google.maps.event.trigger(window.pano, 'resize');

    // POVをセットし直してもう一押し
    const pov = window.pano.getPov && window.pano.getPov();
    if (pov) window.pano.setPov({ heading: pov.heading, pitch: pov.pitch });

    // それでも怪しい端末向け：同じpanoIdを再セット（ハードリセット）
    if (hard) {
      const id = window.pano.getPano && window.pano.getPano();
      if (id) window.pano.setPano(id);
    }

    // レース対策でタイマーでもう一度
    setTimeout(() => {
      google.maps.event.trigger(window.pano, 'resize');
    }, 50);
  } catch {}
}

// 初期表示
updateCamUI();

// クリックごとに状態を回す
camBtn.addEventListener("click", async ()=>{
  if (camMode === 'off') {
    await switchTo('back');   // OFF → 外
  } else if (camMode === 'back') {
    await switchTo('front');  // 外 → 内
  } else {
    await switchTo('off');    // 内 → OFF
  }
});

// ページ離脱で停止（既存の pagehide ハンドラがあれば併存OK）
window.addEventListener('pagehide', stopCamStream);
// ★ バックグラウンド復帰時の黒対策
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && camMode !== 'off' && camEl.srcObject) {
    camEl.play().catch(()=>{});
  }
});

/***** デバイス方位センサーで Street View を回す *****/
if (window.DeviceOrientationEvent) {
  window.addEventListener("deviceorientationabsolute", handleOrientation, true);
  window.addEventListener("deviceorientation", handleOrientation, true);
}

function handleOrientation(event) {
  if (!window.pano) return;

  let heading = null;

  if (typeof event.webkitCompassHeading !== "undefined") {
    // iOS (Safari) 用
    heading = event.webkitCompassHeading;
  } else if (event.alpha !== null) {
    // Android Chrome 等
    heading = 360 - event.alpha; // alphaは時計回り、Street Viewは逆向き
  }

  if (heading !== null) {
    window.pano.setPov({
      heading: heading,
      pitch: 0
    });
    // HUDに表示
    const hdgEl = document.getElementById("hdg");
    if (hdgEl) hdgEl.textContent = heading.toFixed(0);
  }
}

let gyroEnabled = false;
async function enableOrientationTracking() {
  // iOS（Safari）: requestPermission が必要
  if (typeof DeviceOrientationEvent !== "undefined" &&
      typeof DeviceOrientationEvent.requestPermission === "function") {
    try {
      const state = await DeviceOrientationEvent.requestPermission(); // ← ユーザー操作直後にしか呼べません
      if (state !== "granted") { setStatus("方位センサーの許可が得られませんでした"); return; }
    } catch (e) {
      setStatus("方位センサーの許可要求に失敗"); return;
    }
  }
  // 許可後にイベント購読（iOS/Android両対応）
  window.addEventListener("deviceorientationabsolute", handleOrientation, true);
  window.addEventListener("deviceorientation", handleOrientation, true);
  gyroEnabled = true;
  setStatus("方角追従を開始");
  document.getElementById("gyroBtn").textContent = "🧭 方角追従ON（稼働中）";
}

// 既存の micBtn の click にぶら下げてもOK（最初のユーザー操作を活用）
document.getElementById("gyroBtn").addEventListener("click", () => {
  if (!gyroEnabled) enableOrientationTracking();
});

/***** foolをタップで非表示・表示 *****/
let forceStopVisible = false; 

const uiButtons = [
  document.getElementById('gyroBtn'), // ない場合もあるので後でnullチェック
  document.getElementById('stopBtn'),
  document.getElementById('camBtn'),
  document.querySelector('.hud'),
];

let uiHidden = false;
function setUIHidden(next) {
  uiHidden = next;
  uiButtons.forEach(el => {
    if (!el) return;
    // ★ recが録音中、または強制表示フラグが立っている場合は stopBtn を隠さない
    if (el === stopBtn && (forceStopVisible || (rec && rec.state === 'recording'))) {
      el.classList.remove('hidden');
      el.style.display = 'block';
      return;
    }
    el.classList.toggle('hidden', uiHidden);
  });
}
/***** Step3：MediaRecorder 録音 → STT → 会話API *****/
let stream=null, rec=null, chunks=[], stopLevel=null;
const stopBtn= document.getElementById('stopBtn');

function pickAudioMime(){
  const c=["audio/webm;codecs=opus","audio/webm","audio/mp4;codecs=mp4a.40.2","audio/mp4"]; 
  if(!window.MediaRecorder?.isTypeSupported) return ""; 
  for (const t of c) if (MediaRecorder.isTypeSupported(t)) return t; 
  return ""; }

// 入力レベルメーター
function startLevelMeter(stream){
  const AC = window.AudioContext || window.webkitAudioContext; const ac = new AC();
  const src = ac.createMediaStreamSource(stream); const an = ac.createAnalyser(); an.fftSize=1024; src.connect(an);
  const data = new Uint8Array(an.frequencyBinCount); const bar = document.getElementById('levelBar'); let raf=0;
  (function tick(){ an.getByteTimeDomainData(data); let sum=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
    const rms = Math.sqrt(sum/data.length); bar.style.width = Math.min(100, Math.round(rms*180)) + "%"; raf=requestAnimationFrame(tick); })();
  return ()=>{ cancelAnimationFrame(raf); ac.close(); };
}

async function preflightMic(){
  const s = await navigator.mediaDevices.getUserMedia({ audio:true }); s.getTracks().forEach(t=>t.stop());
}

async function sendToSTT(blob){
  const res = await fetch(STT_URL, { method:'POST', headers:{ 'Content-Type': blob.type || 'application/octet-stream' }, body: await blob.arrayBuffer() });
  if (!res.ok) throw new Error('STT HTTP '+res.status); const j = await res.json().catch(()=>({text:''})); return j.text || j.result || '';
}

async function askChat(text){
  try{
    const res = await fetch(CHAT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({
      model:"gpt-4o-mini", stream:true,
      messages:[ {role:"system", content:"あなたは元気な少年キャラ『Fool』です。短い日本語セリフで返答。敬称不要。絵文字は控えめ。"}, {role:"user", content:text} ]
    }) });
    if (!res.ok || !res.body){ setStatus("接続エラー("+res.status+")"); return; }

    clearReply(); // ← テロップを空にしてから
    const reader = res.body.getReader(); const dec = new TextDecoder(); let buf="";
    for(;;){
      const {value,done} = await reader.read(); if(done) break;
      buf += dec.decode(value,{stream:true});
      let nl;
      while((nl = buf.indexOf("\n"))>=0){
        const line = buf.slice(0,nl).trim(); buf = buf.slice(nl+1);
        if(!line.startsWith("data:")) continue;
        const payload=line.slice(5).trim(); if(payload==="[DONE]") {buf=""; break;}
        try{
          const j = JSON.parse(payload);
          const delta = j?.choices?.[0]?.delta?.content || "";
          if(delta) appendReplyChunk(delta); // ← 会話本文はテロップだけに流す
        }catch{}
      }
    }
  }catch(e){
    setStatus("通信エラー: "+(e?.message||e)); // ← エラーはHUDだけ
  }
}

async function startRecording(){
  if (!isSecureContext) { setStatus('HTTPSで開いてください'); return; }
  if (!navigator.mediaDevices?.getUserMedia) { setStatus('getUserMedia未対応'); return; }

  setStatus('権限取得中…');
  try{ await preflightMic(); }catch(e){ setStatus('権限取得失敗'); return; }

  setStatus('録音初期化…');
  try{ stream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:true, noiseSuppression:true, autoGainControl:true, channelCount:1 } }); }
  catch(e){ setStatus('録音用ストリーム失敗'); return; }

  try{ stopLevel = startLevelMeter(stream); }catch{}

  const mime = pickAudioMime();
  try{ rec = mime ? new MediaRecorder(stream,{mimeType:mime}) : new MediaRecorder(stream); }
  catch(e){ setStatus('MediaRecorder作成失敗'); return; }

  chunks=[];
  rec.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
  rec.onstart = ()=>{ setStatus('録音中…話しかけてね'); stopBtn.disabled = false; };
  rec.onstop = async ()=>{
    stopBtn.disabled = true;
  
    try { stopLevel && stopLevel(); } catch {}
    try { stream.getTracks().forEach(t=>t.stop()); } catch {}
  
    // （任意）最後の dataavailable を取りこぼさない保険
    // await new Promise(r => setTimeout(r, 0));
  
    const type = rec.mimeType || (chunks[0] && chunks[0].type) || 'audio/webm';
    const blob = new Blob(chunks, { type });
  
    try {
      setStatus('STT送信中…');
      let text = '';
      try {
        text = await sendToSTT(blob);
      } catch(e) {
        setStatus('STT失敗');
        return;
      }
      if (!text) {
        setStatus('（聞き取れなかったかも）');
        return;
      }
  
      // 会話はテロップだけに
      showReplyThinking();
      await askChat(text);
  
    } finally {
      // ← 成否に関わらず必ず後片付け
      forceStopVisible = false;
      if (uiHidden) stopBtn.classList.add('hidden');
      stopBtn.style.display = 'none';
    }
  };
  try{ rec.start(2000); }catch(e){ setStatus('rec.start失敗'); }
}

stopBtn.addEventListener('click', ()=>{
  try{ rec && rec.stop(); }catch{}
  forceStopVisible = false;                 // ★追加
  if (uiHidden) stopBtn.classList.add('hidden'); // ★追加
  stopBtn.style.display = "none";
});


/***** 便利：ページ離脱で停止 *****/
window.addEventListener('pagehide', ()=>{ try{ rec && rec.stop(); }catch{} try{ stream && stream.getTracks().forEach(t=>t.stop()); }catch{} });
</script>

<!-- ★YOUR_API_KEY をあなたのキーに置き換え -->
<script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAQQHZONAJ27HZwG20IJbRYZXZ6ADxbtP0&v=weekly"></script>
</body>
</html>